{"version":3,"sources":["truncate.js","TaskDetails.js","Task.js","Node.js","Cluster.js","App.js","serviceWorker.js","index.js"],"names":["truncate","input","max_length","length","substring","TaskDetails","props","task","status","completed","updated","created","deleted","remaining","total","millis_per_document","running_time_in_nanos","docs_per_second","value","max","style","width","toFixed","Date","toISOString","substr","title","description","Task","doAutoRefresh","clusterUrl","taskUrl","node","id","useState","taskJson","setTaskJson","fetchTaskData","fetch","then","response","json","useEffect","console","log","JSON","stringify","action","startsWith","areTaskDetailsInteresting","autoRefresh","setTimeout","border","display","type","start_time_in_millis","toLocaleTimeString","cancellable","toString","Node","tasks","Object","keys","sort","map","key","filter","t","indexOf","name","ip","roles","Cluster","setClusterUrl","clusterJson","setClusterJson","setDoAutoRefresh","fetchClusterData","url","nodes","onChange","e","target","onClick","checked","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.8839ae1c.chunk.js","sourcesContent":["const truncate = (input, max_length) => input.length > max_length ? `${input.substring(0, max_length)}...` : input;\nexport {truncate as default};","import React from 'react';\nimport truncate from './truncate';\n\nconst TaskDetails = (props) => {\n    const task = props.task.task;\n    if(!task)\n        return '[no task details]';\n    const status = task.status;\n    const completed = status ? status.updated + status.created + status.deleted\n        : null;\n    const remaining = status.total - completed;\n    const millis_per_document = task.running_time_in_nanos / completed / 1e6;\n    const docs_per_second = completed / task.running_time_in_nanos * 1e9;\n    const hhmmss = millis => new Date(millis).toISOString().substr(11, 8);\n\n    return status ? <div>\n        <progress value={completed} max={status.total} style={{width:\"500px\"}}/>\n        <br/>\n        Velocity: {docs_per_second.toFixed(1)} docs/s\n        <br/>\n        Updated: {status.updated} Created: {status.created} Deleted: {status.deleted} Total: {status.total}\n        <br/>\n        Remaining: {remaining} ETA: {hhmmss(millis_per_document * remaining)}\n        <br/>\n        Description: <code title={task.description}>{truncate(task.description, 80)}</code>\n    </div> : null;\n};\n\nexport default TaskDetails;","import React, { useState, useEffect } from 'react';\nimport TaskDetails from \"./TaskDetails\";\n\nconst Task = (props) => {\n    const task = props.task;\n    const clusterUrl = props.clusterUrl;\n    const doAutoRefresh = props.doAutoRefresh;\n    const taskUrl = props.clusterUrl + \"/_tasks/\" + task.node+\":\"+task.id;\n\n    const [taskJson, setTaskJson] = useState();\n\n    const areTaskDetailsInteresting = (task) => task.action.startsWith(\"cluster:monitor\") === false;\n\n    const fetchTaskData = () => {\n        fetch(taskUrl).then((response) => {\n            return response.json();\n        }).then(\n            (json) => {\n                setTaskJson(json);\n            }\n        );\n    };\n\n    useEffect(() => {\n        console.log('looking at task '+ JSON.stringify(task));\n        if(areTaskDetailsInteresting(task)){\n            console.log('it was interesting');\n            fetchTaskData()\n        }\n    }, []);\n\n    const autoRefresh = () => {\n        if(!doAutoRefresh)\n            return;\n        fetchTaskData();\n        setTimeout(()=> autoRefresh(), 10000);\n    }\n\n    useEffect(()=>autoRefresh(), \n        [doAutoRefresh]);\n\n    return <div>\n        <table border=\"1\" style={{display:\"inline-table\"}}>\n            <thead>\n                <tr>\n                    <th>id</th>\n                    <th>action</th>\n                    <th>type</th>\n                    <th>started</th>\n                    <th>running time</th>\n                    <th>cancellable</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>{task.id}</td>\n                    <td>{task.action}</td>\n                    <td>{task.type}</td>\n                    <td>{new Date(task.start_time_in_millis).toLocaleTimeString()}</td>\n                    <td>{new Date(task.running_time_in_nanos / 1e6).toISOString().substr(11, 8)}</td>\n                    <td>{task.cancellable.toString()}</td>\n                </tr>\n            </tbody>\n        </table>\n        <br/>\n        {taskJson ? <TaskDetails task={taskJson}/> : null}\n    </div>;\n};\n\nexport default Task;","import React from 'react';\nimport Task from './Task';\n\n\nconst Node = (props) => {\n    const node = props.node;\n    const clusterUrl = props.clusterUrl;\n    const doAutoRefresh = props.doAutoRefresh;\n\n    const tasks = node.tasks ? Object.keys(node.tasks).sort()\n        .map(key=>node.tasks[key])\n            .filter(t=>t.action.indexOf(\"reindex\") !== -1)\n        .map(t=><Task key={t.id} task={t} clusterUrl={clusterUrl} doAutoRefresh={doAutoRefresh}/>) \n        : null;\n\n    return <div>\n        <h3>{node.name}</h3>\n        clusterUrl: {clusterUrl}\n        auto: {doAutoRefresh ? \"on\":\"off\"}\n        <ul>\n            <li>ip: {node.ip}</li>\n            <li>roles: {JSON.stringify(node.roles)}</li>\n        </ul>\n        Tasks:\n        {tasks}\n    </div>\n}\n\nexport default Node;","import React, { useState, useEffect } from 'react';\nimport Node from './Node';\nimport truncate from './truncate';\n\nconst Cluster = () => {\n    const [clusterUrl, setClusterUrl] = useState('http://localhost:9200');\n    const [clusterJson, setClusterJson] = useState();\n    const [doAutoRefresh, setDoAutoRefresh] = useState(true);\n\n    const fetchClusterData = () => {\n        const url = clusterUrl + '/_tasks';\n        console.log(url);\n        fetch(url).then((response) => {\n            return response.json();\n        }).then(\n            (json) => {\n                setClusterJson(json);\n            }\n        );\n    }\n\n    const autoRefresh = () => {\n        if(!doAutoRefresh)\n            return;\n        fetchClusterData();\n        setTimeout(()=> autoRefresh(), 10000);\n    }\n\n    // TODO ignore warning in linter\n    useEffect(() => {\n        fetchClusterData();\n    }, []); \n\n    useEffect(()=>{\n        if(!doAutoRefresh)\n            return;\n        autoRefresh();\n    }, [doAutoRefresh])\n\n    const nodes = clusterJson ? Object.keys(clusterJson.nodes)\n        .map(key => <Node node={clusterJson.nodes[key]} key={key} clusterUrl={clusterUrl} doAutoRefresh={doAutoRefresh} />)\n        : null;\n\n    return <div>\n        <h1>Elasticsearch cluster @ {clusterUrl}</h1>\n        <span>Cluster URL: <input value={clusterUrl} onChange={(e) => setClusterUrl(e.target.value)}></input>\n        </span>\n        <button onClick={fetchClusterData}>&#x21bb; Refresh</button>\n        <label><input type=\"checkbox\" checked={doAutoRefresh} onChange={e=>setDoAutoRefresh(e.target.checked)}/>Auto-refresh</label>         \n        {clusterJson ? \n           <pre title={clusterJson}>Status: {truncate(JSON.stringify(clusterJson), 100)}</pre>\n           : null\n        }\n        {nodes}\n    </div>\n}\n\n\nexport default Cluster;","import React from 'react';\nimport './App.css';\nimport Cluster from './Cluster';\n\nfunction App() {\n  return (\n    <Cluster></Cluster>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}